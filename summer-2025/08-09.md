### bin 和 elf的区别
bin 纯二进制程序或者数据
elf 包含元数据，文件头，section，段等信息

elf->bin
```shell
arm-none-eabi-objcopy -O binary firmware.elf firmware.bin
```
```makefile
$(call run_cmd,$(OBJCOPY),$(OUT_ELF) --strip-all -O binary $@)
```

操作系统启动过程
===
启动过程

`arceos/modules/axhal/src/platform/riscv64_qemu_virt/boot.rs`
## 1. _start:
建立虚拟空间给前期启动用，就是没有正式进入内核操作系统前
```plaintext
0xEF 是1G内存大页标志，只看VPN[2]
Sv39:1G的恒等映射，0x8000_0000..0xc000_0000，## 给用户使用
Sv39:1G的高位映射，0xffff_ffc0_8000_0000..0xffff_ffc0_c000_0000，## 给内核使用
```

初始化mmu，调整sp
## 2. 转入rust_entry
起点：`arceos/modules/axhal/src/platform/riscv64_qemu_virt/mod.rs`  
set trap vector base # 设置stvec寄存器


## 3. 转入 rust_main 
arceos的起点
`arceos/modules/axruntime/src/lib.rs`
### 3.1 内存
**调整内核虚拟空间布局，顶替之前虚拟空间布局。**  
kernel image ragion
1. global-allocator 
axalloc::global_init 是虚拟地址，最小32K
> 为啥要选出要给最大的，不明白？
> 各个kenel reign不是最大的，就global-add() 为啥？？？
2. init_memory_management
> 创建内核空间，这个内核空间，还是在哪1G的高位映射吗？？？
Sv39 更新satp寄存器，区别月上面1G映射。
### 3.2 任务
创建idleTask，创建maintask，并把当前task指向maintask
创建定时器响应事件接收队列
### 3.3 设备
初始化设备驱动树
init_drivers（全局设备和BUS设备）
### 3.4 文件系统（块设备延伸）
初始化文件系统
从块设备中加载进来
### 3.5 中断
注册设置timer中断

## 4. 执行main（）函数
> 这个是操作系统入口，这个main函数的地址是从哪获取的？？？
> ```rust
> extern "C" {
>     fn main(); ## 这个main函数在哪？
> }
> ```

## 5. 退出当前任务，
1. idle不能退出，
1. 把当前任务添加到退出队列中
>（什么时候清除呢？？？）我猜是没有其它引用这个任务的时候。

# 名词解释
PIC（Position-Independent Code，地址无关代码） 是指可以在内存中任意地址加载并正确运行的代码，不依赖固定的绝对地址
1. 使用相对地址：通过相对于当前 PC（程序计数器）的偏移量访问数据和代码。
2. 全局偏移表（GOT）：动态链接时通过 GOT 间接访问全局变量和函数。
3. PC 相对寻址指令：RISC-V 提供专门的指令支持 PIC。

指令支持：
1. auipc（Add Upper Immediate to PC）
```riscv
auipc a0, 0           # a0 = PC + (0 << 12)
```
2. jalr（Jump and Link Register）
```riscv
auipc ra, 0           # ra = PC + 0
jalr  ra, ra, offset  # 跳转到 PC + offset
```
3. lw/ld 等加载指令结合 auipc
```riscv
auipc a0, 0           # a0 = PC + 0
lw    a1, offset(a0)  # 加载 PC + offset 处的数据
```

注：全局变量一般是绝对地址访问的


# 虚拟设备
通过映射MMIO进行管理的。16M空间大小
```rust
const VM_ASPACE_BASE: usize = 0x0;
const VM_ASPACE_SIZE: usize = 0x7fff_ffff_f000;
const PHY_MEM_START: usize = 0x8000_0000;
const PHY_MEM_SIZE: usize = 0x100_0000;
const KERNEL_BASE: usize = 0x8020_0000;
```
疑问1：
> 虚拟空间大小0x7fff_ffff_f000，这个大小有啥说法？是Sv48分页机制？
> 物理空间大小是16M
