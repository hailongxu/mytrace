
# 虚拟机运行

## 启动虚拟机前置工作：
1.  只对hstatus 寄存器设置 spv，和 spvp位
    其余是对sret准备的数据

    hstatus 设置 hstatus::spv::Guest; 误认为上次是从guest切换的  
    hstatus 设置 hstatus::spvp::Supervisor; hs有权限访问guest内存空间  
    CSR.hstatus.write_value 来真正设置寄存器

    csrrs t0, 0x100, x0 # 无副作用读取sstatus  
    A: sstatus.set_spp(sstatus::SPP::Supervisor); # 设置标志，没有实际操作寄存器，  
    B: 设置操作系统的入口地址：sepc=0x80200000  
    A,B这两个都是为sret准备的，等sret后，转到guest的hs模式。  

2.  启用也就是EPT EPT（扩展页表，也叫二级页表）的 根页表物理地址（4 KiB 对齐），更新寄存器 hgatp，启用后，地址空间是64P，56位



## 进入vm，过程：
    保存通用寄存器 到context中(不包括 T0-T6和a0)，这个只是用到了t1，剩下的临时寄存器为啥没有保存？？
    保存并更新CSR寄存器(sstatus，hstatus, scounteren，sepc, stvec, sscratch) 到context中，
    载入通用寄存器 从context中
    sret，完成切换

    这里的疑问，每一步的CSR寄存器的更新，后续的寄存器的访问都有啥影响？
    这里的最佳顺序是啥？

    hstatus.SPV=1 会立即触发寄存器替换吗？是的，见下面描述。


Additional CSRs are provided to HS-mode, but not to VS-mode, to manage two-stage address translation and to control the behavior of a VSmode guest: hstatus, hedeleg, hideleg, hvip, hip, hie, hgeip, hgeie, henvcfg, henvcfgh, hcounteren, htimedelta, htimedeltah, htval, htinst, and hgatp.
Furthermore, several virtual supervisor CSRs (VS CSRs) are replicas of the normal supervisor CSRs. For example, vsstatus is the VS CSR that duplicates the usual sstatus CSR.  
When V=1, the VS CSRs substitute for the corresponding supervisor CSRs, taking over all functions of the usual supervisor CSRs except as specified otherwise. Instructions that normally read or modify a supervisor CSR shall instead access the corresponding VS CSR. When V=1, an attempt to read or write a VS CSR directly by its own separate CSR address causes a virtual instruction exception. (Attempts from U-mode cause an illegal instruction exception as usual.) The VS CSRs can be accessed as themselves only from M-mode or HS-mode.  
While V=1, the normal HS-level supervisor CSRs that are replaced by VS CSRs retain their values but do not affect the behavior of the machine unless specifically documented to do so. Conversely, when V=0, the VS CSRs do not ordinarily affect the behavior of the machine other than being readable and writable by CSR instructions.  
Some standard supervisor CSRs (senvcfg, scounteren, and scontext, possibly others) have no matching VS CSR. These supervisor CSRs continue to have their usual function and accessibility even when V=1, except with VS-mode and VU-mode substituting for HS-mode and U-mode. Hypervisor software is expected to manually swap the contents of these registers as needed.


## 退出vm的过程
先获取context VmCpuRegisters，从sscratch，这个scratch谁给它的？一个是hs空间，一个是vs地址空间，这两个地址空间是不同的，

# 虚拟中断
VCPU:
虚拟机是借助于硬件来完成，提供了和S态CPU一样的环境来实现的。  
接管了VS下不能处理的中断，并提供了Guest下物理地址映射。  
是一个可以被CPU调度的执行单元上附加了H态和V态之间切换所需要的上下文信息，它有执行地址，但是没有明确指明栈空间，栈空间复用了V态下的线程的栈空间，这也说明，VCPU，不是线程，又类似线程。切换需标志：SPV，SPVP；SPP；EPT

VCPU，如何响应陷阱和中断的，通过把任何陷阱和中断的地址设置成vm_exit地址，其实就是退出虚拟机，退出虚拟机后，就进入了HS态，在HS态，从寄存器的值，再处理异常。

1. 疑问1：在vmexit_handler时，不是把寄存器的各个值，都保存起来了，为啥还要再从寄存器中读一遍？
2. 疑问2：VmCpuRegisters，这个变量是在hs的栈中，vs是如何能访问到这个变量？这是在不同的虚拟空间中的
3. 疑问3：_guest_exit执行到这里时，实在VS，还是HS态？



时钟中断的前提：
1. delegate时钟中断，hideleg.VIRTUAL_SUPERVISOR_TIMER
1. 使能 sie.SUPERVISOR_TIMER


VCPU：对时钟中断的创建过程
1. 首先让HS接管VS的时钟中断，
1. 创建时钟中断时 调用 sbi-call-setimer
1. 关闭VS timer 中断 hvip.VIRTUAL_SUPERVISOR_TIMER
1. 打开HS的时钟接收，SIE.SUPERVISOR_TIMER

VCPU，HS响应时钟中断
1. 虚拟获得时钟到中断
1. HS接管并拦截到，
1. 使能VS中断 hvip.VIRTUAL_SUPERVISOR_TIMER // 中断注入
1. 清除HS的时钟接收 SIE.SUPERVISOR_TIMER
