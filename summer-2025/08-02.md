
# 虚拟机运行

##  代理设置
```rust
pub unsafe fn setup_csrs() {
   // Delegate some synchronous exceptions.
    CSR.hedeleg.write_value(
        traps::exception::INST_ADDR_MISALIGN
            | traps::exception::BREAKPOINT
            | traps::exception::ENV_CALL_FROM_U_OR_VU
            | traps::exception::INST_PAGE_FAULT
            | traps::exception::LOAD_PAGE_FAULT
            | traps::exception::STORE_PAGE_FAULT
            | traps::exception::ILLEGAL_INST,
    );

    // Delegate all interupts.
    CSR.hideleg.write_value(
        traps::interrupt::VIRTUAL_SUPERVISOR_TIMER
            | traps::interrupt::VIRTUAL_SUPERVISOR_EXTERNAL
            | traps::interrupt::VIRTUAL_SUPERVISOR_SOFT,
    );
    ...
}
```
> 这里的代理是，把这些异常和中断交由VS响应还是HS响应？？？

## 启动虚拟机前置工作：
1.  创建虚拟机虚拟内存，大小空间为Sv39=512G 0~0x7fff_ffff_ffff，并设置根页表
2.  创建虚拟CPU
    只对hstatus 寄存器设置 spv，和 spvp位
    其余是对sret准备的数据

    // 伪造Guest返回现场标志  
    hstatus 设置 hstatus::spv::Guest; 误认为上次是从guest切换的  
    hstatus 设置 hstatus::spvp::Supervisor; hs有权限访问guest内存空间  
    CSR.hstatus.write_value 来真正设置寄存器， 指令：
    `core::arch::asm!("csrw {csr}, {rs}", csr = const V, rs = in(reg) value);`
    
    > 这个设置寄存器会影响啥？？？还是只影响寄存器本身的值？ 再进入VM的时候，又设置一遍，需要两次设置吗？还是必须的？缘由是啥？

    csrrs t0, 0x100, x0 # 无副作用读取sstatus  
    A: sstatus.set_spp(sstatus::SPP::Supervisor); # 设置标志，没有实际操作寄存器，  
    B: 设置操作系统的入口地址：sepc=0x80200000 
    A,B这两个都是为sret准备的，等sret后，转到guest的hs模式。  

3.  启用也就是EPT EPT（扩展页表，也叫二级地址）的 根页表物理地址（4 KiB 对齐），更新寄存器 hgatp，启用后，模式Sv39x4，mode=8。hgatp.PPN宽度为44位 因为Host物理地址宽度大于等于56=44+12位，容纳地址空间为16P。因为兼容Sv48寻址空间是48位，和将来的扩展。这个44位是规定的，必须这样。这个设置后，并不会立即生效，因为需要在guest模式下，才能出发二级地址。
hgapt的根页表扩充了两位也就是从9位=512B到11位=2K，也即是Sv39x4=2T虚拟空间。


## 进入vm， 使用sret
1. 中断状态保存，关中断 指令：`unsafe { core::arch::asm!("csrrc {}, sstatus, {}", out(reg) flags, const SIE_BIT) };`

`arceos/modules/riscv_vcpu/src/guest.S`
2. 保存通用寄存器 到context（regs）中(不包括 T0-T6和A0)，这个只是用到了t1，剩下的临时寄存器为啥没有保存？因为A0就存到了sscratch中了？

保存并更新CSR寄存器(sstatus，hstatus, scounteren，sepc, stvec, sscratch) 到context中。hstatus是HS特有的，所以不需要交换，
> ```
> ld    t1, ({guest_sepc})(a0)
> csrw  sepc, t1
> ```
> 此时 sepc应该是HS态下的，不应该设置的是vsepc吗？？？或者说vsepc值的更改是从sepc寄存器中读出来的？在执行sret过程中。
> 为啥guest_sepc没有和hyper_sepc进行交换？？？  
> 同理vstvec，为啥没有和stvec进行互换，是不是可以这样理解，stvec是对M态而言的，所以它并不和VS态进行交互，所以，没有进行互换？？？同理sepc是不是也可以这样理解？
> ```rust
> /* Save sscratch and replace with pointer to GuestInfo. */
> csrrw t1, sscratch, a0
> sd    t1, ({hyp_sscratch})(a0)
> ```
> 同理为啥sscratch和vsscratch没有进行交换呢？  
> scratch指向的是`let mut arch_vcpu = RISCVVCpu::init();`这里的一个局部变量，在hs的虚拟空间中，在VS态下，应该访问不了猜对？再者说，如果指向的是同一个地址，也不需要保存。


载入通用寄存器 从context中  
3. sret，完成切换
4. 中断状态恢复

这里的疑问，每一步的CSR寄存器的更新，后续的寄存器的访问都有啥影响？
这里的最佳顺序是啥？

hstatus.SPV=1 会立即触发寄存器替换吗？是的，见下面描述。


Additional CSRs are provided to HS-mode, but not to VS-mode, to manage two-stage address translation and to control the behavior of a VSmode guest: hstatus, hedeleg, hideleg, hvip, hip, hie, hgeip, hgeie, henvcfg, henvcfgh, hcounteren, htimedelta, htimedeltah, htval, htinst, and hgatp.
Furthermore, several virtual supervisor CSRs (VS CSRs) are replicas of the normal supervisor CSRs. For example, vsstatus is the VS CSR that duplicates the usual sstatus CSR.  
When V=1, the VS CSRs substitute for the corresponding supervisor CSRs, taking over all functions of the usual supervisor CSRs except as specified otherwise. Instructions that normally read or modify a supervisor CSR shall instead access the corresponding VS CSR. When V=1, an attempt to read or write a VS CSR directly by its own separate CSR address causes a virtual instruction exception. (Attempts from U-mode cause an illegal instruction exception as usual.) The VS CSRs can be accessed as themselves only from M-mode or HS-mode.  
While V=1, the normal HS-level supervisor CSRs that are replaced by VS CSRs retain their values but do not affect the behavior of the machine unless specifically documented to do so. Conversely, when V=0, the VS CSRs do not ordinarily affect the behavior of the machine other than being readable and writable by CSR instructions.  
Some standard supervisor CSRs (senvcfg, scounteren, and scontext, possibly others) have no matching VS CSR. These supervisor CSRs continue to have their usual function and accessibility even when V=1, except with VS-mode and VU-mode substituting for HS-mode and U-mode. Hypervisor software is expected to manually swap the contents of these registers as needed.


## 退出vm的过程
先获取context VmCpuRegisters，从sscratch，这个scratch谁给它的？一个是hs空间，一个是vs地址空间，这两个地址空间是不同的，
> 疑问
> ```rust
> .align 2
> _guest_exit:
>     /* Pull GuestInfo out of sscratch, swapping with guest's a0 */
>     csrrw a0, sscratch, a0
> ```
> 执行到_guest_exit的时候，这个时候，是在vs态，还是在hs态？


# 虚拟中断
设计理解：让VM像一个独立的操作系统，能调用各种功能，如果VM内核态不能完成，交给它的宿主去完成，交给的过程是透明的，VM完全不知道，这个接管交互过程，主要涉及到2点，内存缺页，中断异常转发。把不能干的活转交给中间层就是HS或者说宿主来处理，这两者之间就是通过一组寄存器配置来完成的。通过中间层来共同分享对硬件的共享使用。设计方法：分时+挂起，不是指令级模拟。
## VCPU:
- 虚拟机是借助于硬件来完成，提供了和S态CPU一样的环境来实现的。  
- 接管了VS下不能处理的中断，并提供了Guest下物理地址映射。  
- 是一个可以被CPU调度的执行单元上附加了H态和V态之间切换所需要的上下文信息，它有执行地址，但是没有明确指明栈空间，栈空间复用了V态下的线程的栈空间，这也说明，VCPU，不是线程，又类似线程。切换需标志：SPV，SPVP；SPP；EPT
- 
VCPU，如何响应陷阱和中断的，通过把任何陷阱和中断的地址设置成vm_exit地址，其实就是退出虚拟机，退出虚拟机后，就进入了HS态，在HS态，从寄存器的值，再处理异常。

> 1. 疑问1：在vmexit_handler时，不是把寄存器的各个值，都保存起来了，为啥还要再从寄存器中读一遍？
> 2. 疑问2：VmCpuRegisters，这个变量是在hs的栈中，vs是如何能访问到这个变量？这是在不同的虚拟空间中的
> 3. 疑问3：_guest_exit执行到这里时，实在VS，还是HS态？



## 时钟中断的前提：
1. 代理时钟中断，hideleg.VIRTUAL_SUPERVISOR_TIMER
1. 使能 sie.SUPERVISOR_TIMER
比如上面的指令：
```rust
    CSR.hideleg.write_value(traps::interrupt::VIRTUAL_SUPERVISOR_TIMER)
```
1. 时钟中断如何实现注入的？hvip寄存器，可以让时钟中断寄存器的响应继续进行（可以理解成断点续传）


## VCPU：对时钟中断的创建过程
1. 首先让HS接管VS的时钟中断，
1. 创建时钟中断时 调用 sbi-call-setimer
1. 关闭VS timer 中断 hvip.VIRTUAL_SUPERVISOR_TIMER
1. 打开HS的时钟接收，SIE.SUPERVISOR_TIMER
timer设置是通过exception进行响应设置的：
```rust
    SbiMessage::SetTimer(timer) => {
        info!("Set timer... ");
        sbi_rt::set_timer(timer as u64);
        // Clear guest timer interrupt
        CSR.hvip
            .read_and_clear_bits(traps::interrupt::VIRTUAL_SUPERVISOR_TIMER);
        //  Enable host timer interrupt
        CSR.sie
            .read_and_set_bits(traps::interrupt::SUPERVISOR_TIMER);
    }
```

## VCPU，HS响应时钟中断
1. 虚拟机获得时钟到中断
1. HS接管并拦截到，
1. 使能VS中断 hvip.VIRTUAL_SUPERVISOR_TIMER // 中断注入
1. 清除HS的时钟接收 SIE.SUPERVISOR_TIMER
timer响应是通过中断接收的：
```rust
Trap::Interrupt(Interrupt::SupervisorTimer) => {
    info!("timer irq emulation");
    // Enable guest timer interrupt
    CSR.hvip
        .read_and_set_bits(traps::interrupt::VIRTUAL_SUPERVISOR_TIMER);
    // Clear host timer interrupt
    CSR.sie
        .read_and_clear_bits(traps::interrupt::SUPERVISOR_TIMER);
    Ok(AxVCpuExitReason::Nothing)
}
```
